---
title: "From 0 to 1: The Rise of Vibe Coding"
date: 2025-03-30
tags: [AI, Programming, Vibe Coding]
categories: ["Tech Notes"]
draft: false
description: "This article explores the rise of Vibe Coding and how AI is transforming collaborative software development."
---

> (So... I realized it got a bit long, so I decided to split it into two parts. If you're commuting, sipping tea, or just trying to avoid a meeting, this part takes about 7 minutes. Relax and enjoy.)

Have you heard of Vibe Coding? In today’s fast-moving AI landscape, there’s a rising movement that relies on the power of AI to generate what we need using just “verbal spells”—that’s Vibe Coding. Of course, when I say “verbal spells,” I don’t mean talking nonsense. I mean using clear language, logic, and creativity to guide AI—like a new form of human-machine collaboration.

The term “Vibe Coding” was first introduced by Andrej Karpathy, founder of Eureka Labs and former deep learning and computer vision researcher at OpenAI. The term has now become widely recognized—even earning a dedicated Wikipedia entry. If you’re wondering how effective this kind of approach is, just look at how many startups are using AI to build commercially viable products with minimal manpower. That alone says a lot. 

It also prompts us to rethink what it means to be a developer. Maybe coding is no longer about how fast you type, but how clearly you can express your needs and logic.

As a software and firmware engineer, I’ve also started integrating this approach into my daily work. For me, it’s a crucial leap from 0 to 1. If you have good ideas and solid logical thinking, chances are you can get an AI to help build a working app, website, or even a shell script. With AI’s help, multitasking becomes easier than ever, and expanding our capabilities through AI collaboration might just be the most important thing for the next five—or even three—years.

## From 0 to 1, and 100 to 101

So why did I say “chances are”? With today’s widely available LLMs, if your project is lightweight and goal is clear, and if your prompt is well-written, you’ll often get decent results.

For example, take simple games like Snake or Minesweeper. At this point, not many people can out-code AI on those from scratch. For AI, getting from 0 to 1 is fast and effective. Once you have the core functionality, you can start expanding—add a scoreboard, a lightweight database (to track player rankings?), or a sleek UI? No problem. As long as your prompt is accurate, just hand it over to AI, go make a coffee or tea, and the task might be done before you’re back.

So from 0 to 1 (core features), and even 1 to 100 (expanded features), as long as you're patient and iterate with AI, building something production-ready is no longer out of reach.

But… there’s always a but. What happens beyond 100? What does it take to go from 100 to 101?

(Next time, let’s explore what happens when things get more complex—how AI tackles the 100 to 101 leap, and how we, as engineers, can find our place in this evolving landscape.)
